---
title: "Error Handling: From Silently Failing to Informative"
description: "Strategies for robust error handling that informs users and helps debugging"
date: "2025-03-31"
---

Moving from silent failures and generic "something went wrong" messages to structured, actionable error handling. Good error handling delights users and accelerates debugging.

## Error Classification

```typescript
// Base error class with codes
abstract class AppError extends Error {
  constructor(
    public code: string,
    public statusCode: number,
    message: string,
    public context: Record<string, any> = {}
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}

// Domain-specific errors
class ValidationError extends AppError {
  constructor(message: string, context: any) {
    super("VALIDATION_ERROR", 400, message, context);
  }
}

class PaymentError extends AppError {
  constructor(message: string, context: any) {
    super("PAYMENT_FAILED", 402, message, context);
  }
}

class AuthenticationError extends AppError {
  constructor(message: string) {
    super("UNAUTHORIZED", 401, message);
  }
}

class NotFoundError extends AppError {
  constructor(resource: string) {
    super("NOT_FOUND", 404, `${resource} not found`);
  }
}
```

## User-Facing vs. Internal Errors

```typescript
// ❌ Expose implementation details
try {
  await db.query("SELECT * FROM users WHERE id = $1", [id]);
} catch (error) {
  res.status(500).json({ error: error.message }); // "connection timeout"
}

// ✅ Hide internals, show helpful message
try {
  await db.query("SELECT * FROM users WHERE id = $1", [id]);
} catch (error) {
  logger.error("database_error", { error, query: "..." });
  res.status(500).json({
    error: {
      code: "TEMPORARY_ERROR",
      message: "We're experiencing issues. Please try again in a moment.",
      requestId: req.id, // For support to investigate
    },
  });
}
```

## Structured Error Logging

```typescript
async function processPayment(paymentId: string) {
  try {
    return await chargeCard(paymentId);
  } catch (error) {
    if (error instanceof PaymentError) {
      // Retryable error; queue for retry
      logger.warn("payment_retryable", {
        payment_id: paymentId,
        error_code: error.code,
        retry_after: 60,
      });
      await queue.retry(paymentId, { delay: 60000 });
    } else {
      // Permanent failure; alert team
      logger.error("payment_permanent_failure", {
        payment_id: paymentId,
        error_code: error.code,
        error_message: error.message,
        alert: true,
      });
    }
    throw error;
  }
}
```

## Error Handling Checklist

- [x] Create domain-specific error classes.
- [x] Assign unique, stable error codes (not just HTTP status).
- [x] Include request IDs for traceability.
- [x] Separate user-facing messages from technical details.
- [x] Log full errors with context; never silently catch.
- [x] Distinguish retryable from permanent failures.
- [ ] Build error dashboard to track top failures by code.
- [ ] Implement automatic alerts for critical error rates.

## Error Communication

| Scenario         | User Message                    | Log Level | Action          |
| ---------------- | ------------------------------- | --------- | --------------- |
| Input invalid    | "Email format invalid"          | INFO      | Prompt retry    |
| Payment declined | "Card declined. Try another."   | WARN      | Suggest support |
| Server error     | "Temporary issue. Retry later." | ERROR     | Page and team   |
| Database down    | "We're down for maintenance."   | ERROR     | Auto-alert      |

## Results

- Support tickets from "something broke" → 10% (actionable codes help).
- Debugging time: cut in half (structured logs + request IDs).
- User confidence: "errors feel intentional, not crashes."

## Best Practices

- Never throw generic `Error`; use domain-specific types.
- Always include context (user ID, resource ID, operation).
- Use error codes, not messages, for programmatic handling.
- Log at correct level: INFO (expected), WARN (degraded), ERROR (failure).

## Next

- Build error recovery strategies (circuit breakers, fallbacks).
- Implement error analytics dashboard.
